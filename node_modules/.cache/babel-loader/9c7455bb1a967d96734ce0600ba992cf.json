{"ast":null,"code":"/*\n * extsprintf.js: extended POSIX-style sprintf\n */\n\nvar mod_assert = require('assert');\nvar mod_util = require('util');\n\n/*\n * Public interface\n */\nexports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */\nfunction jsSprintf(ofmt) {\n  var regex = ['([^%]*)', /* normal text */\n  '%', /* start of format */\n  '([\\'\\\\-+ #0]*?)', /* flags (optional) */\n  '([1-9]\\\\d*)?', /* width (optional) */\n  '(\\\\.([1-9]\\\\d*))?', /* precision (optional) */\n  '[lhjztL]*?', /* length mods (ignored) */\n  '([diouxXfFeEgGaAcCsSp%jr])' /* conversion */].join('');\n  var re = new RegExp(regex);\n\n  /* variadic arguments used to fill in conversion specifiers */\n  var args = Array.prototype.slice.call(arguments, 1);\n  /* remaining format string */\n  var fmt = ofmt;\n\n  /* components of the current conversion specifier */\n  var flags, width, precision, conversion;\n  var left, pad, sign, arg, match;\n\n  /* return value */\n  var ret = '';\n\n  /* current variadic argument (1-based) */\n  var argn = 1;\n  /* 0-based position in the format string that we've read */\n  var posn = 0;\n  /* 1-based position in the format string of the current conversion */\n  var convposn;\n  /* current conversion specifier */\n  var curconv;\n  mod_assert.equal('string', typeof fmt, 'first argument must be a format string');\n  while ((match = re.exec(fmt)) !== null) {\n    ret += match[1];\n    fmt = fmt.substring(match[0].length);\n\n    /*\n     * Update flags related to the current conversion specifier's\n     * position so that we can report clear error messages.\n     */\n    curconv = match[0].substring(match[1].length);\n    convposn = posn + match[1].length + 1;\n    posn += match[0].length;\n    flags = match[2] || '';\n    width = match[3] || 0;\n    precision = match[4] || '';\n    conversion = match[6];\n    left = false;\n    sign = false;\n    pad = ' ';\n    if (conversion == '%') {\n      ret += '%';\n      continue;\n    }\n    if (args.length === 0) {\n      throw jsError(ofmt, convposn, curconv, 'has no matching argument ' + '(too few arguments passed)');\n    }\n    arg = args.shift();\n    argn++;\n    if (flags.match(/[\\' #]/)) {\n      throw jsError(ofmt, convposn, curconv, 'uses unsupported flags');\n    }\n    if (precision.length > 0) {\n      throw jsError(ofmt, convposn, curconv, 'uses non-zero precision (not supported)');\n    }\n    if (flags.match(/-/)) left = true;\n    if (flags.match(/0/)) pad = '0';\n    if (flags.match(/\\+/)) sign = true;\n    switch (conversion) {\n      case 's':\n        if (arg === undefined || arg === null) {\n          throw jsError(ofmt, convposn, curconv, 'attempted to print undefined or null ' + 'as a string (argument ' + argn + ' to ' + 'sprintf)');\n        }\n        ret += doPad(pad, width, left, arg.toString());\n        break;\n      case 'd':\n        arg = Math.floor(arg);\n      /*jsl:fallthru*/\n      case 'f':\n        sign = sign && arg > 0 ? '+' : '';\n        ret += sign + doPad(pad, width, left, arg.toString());\n        break;\n      case 'x':\n        ret += doPad(pad, width, left, arg.toString(16));\n        break;\n      case 'j':\n        /* non-standard */\n        if (width === 0) width = 10;\n        ret += mod_util.inspect(arg, false, width);\n        break;\n      case 'r':\n        /* non-standard */\n        ret += dumpException(arg);\n        break;\n      default:\n        throw jsError(ofmt, convposn, curconv, 'is not supported');\n    }\n  }\n  ret += fmt;\n  return ret;\n}\nfunction jsError(fmtstr, convposn, curconv, reason) {\n  mod_assert.equal(typeof fmtstr, 'string');\n  mod_assert.equal(typeof curconv, 'string');\n  mod_assert.equal(typeof convposn, 'number');\n  mod_assert.equal(typeof reason, 'string');\n  return new Error('format string \"' + fmtstr + '\": conversion specifier \"' + curconv + '\" at character ' + convposn + ' ' + reason);\n}\nfunction jsPrintf() {\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift(process.stdout);\n  jsFprintf.apply(null, args);\n}\nfunction jsFprintf(stream) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return stream.write(jsSprintf.apply(this, args));\n}\nfunction doPad(chr, width, left, str) {\n  var ret = str;\n  while (ret.length < width) {\n    if (left) ret += chr;else ret = chr + ret;\n  }\n  return ret;\n}\n\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */\nfunction dumpException(ex) {\n  var ret;\n  if (!(ex instanceof Error)) throw new Error(jsSprintf('invalid type for %%r: %j', ex));\n\n  /* Note that V8 prepends \"ex.stack\" with ex.toString(). */\n  ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;\n  if (ex.cause && typeof ex.cause === 'function') {\n    var cex = ex.cause();\n    if (cex) {\n      ret += '\\nCaused by: ' + dumpException(cex);\n    }\n  }\n  return ret;\n}","map":null,"metadata":{},"sourceType":"script"}